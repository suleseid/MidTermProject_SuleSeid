# Programming Data Structures and Algorithms - Midterm

## 1.Introduce Yourself
  
##  A.Name:
        Suleman Seid.

##  B.Role/Title: 
     	I'm a Computer Science Student and 
        my primary role is to assist users by providing information, answering questions as much as I can, 
        and engaging in conversation in our community.

##  C.Brief Bio: 
     My name is Suleman Seid, a student of Computer Science at Renton Technical College. 
     I am constantly learning technologies in different ways using Google, YouTube, Facebook, Microsoft Office 
     and other technologies in addition to school
     also, I have an interest in being a good technician in computer science in adapting to assist people with a wide range of tasks. 

## 2.State Your Goals:
    I want to improve my skills and knowledge in data science and analytics, 
    and apply them to the health care industry.
    My goal is to use data-driven methods and tools to help health care providers 
    and patients make better decisions and improve their health outcomes. 
    I am eager to learn from the experts and mentors at DEF organization, 
    and contribute to their ongoing projects and initiatives.

### Link at least 3 repositories: Personal Project (See Part 2), best repository, and the 3rd part of this assignment.

```` csharp
https://github.com/suleseid/GA_LinkedListSingly_SuleSeid
https://github.com/suleseid/DataStructures_SulemanSeid
https://github.com/suleseid/MidTermProject_SuleSeid
````
 ## I.Learning Goals/Career Aspirations: 
       a. My primary goal is to provide accurate and helpful responses to user queries.
       b. I aspire to continuously improve my understanding,
          language capabilities, and problem-solving skills.
       c. I have an interest in further deepen expertise in cloud computing 
          and machine learning, ultimately aiming to become a technical lead in a cutting-edge tech company.

## 3.Technologies and Skills:
        a)	As I'm a computer science student, I have some knowledge of various programming languages, 
            including Python, JavaScript, Java, and C#.
        b)	My skills include natural language processing, text generation, 
            and understanding context.
        c)	I can assist with web development, data analysis, and other technical tasks.

## 4.Showcase Projects:
       •  As I am a student, Unfortunately, I don’t have direct links to specific projects, 
          but I can certainly highlight some interesting ones:
       •  Data Analysis: 
                   I have an interest in assisting with data cleaning, visualization, and basic machine-learning tasks.
       •  Portfolio Website (GitHub: link) Description: 
                  Designed and implemented a personal portfolio website showcasing my projects, skills, and professional experience using HTML, CSS, and JavaScript.
       •  Work History: 
                I have been working at SeaTac Airport with Delta airline, as a customer service three years and also with a different company in the same position at the airport. 
```
## Project Relevance and Complexity

## A. How well the provided project aligns with industry standards and job relevance, as well as the complexity demonstrating the ability to solve significant problems:
```csharp

# 1. Relevance to Industry Standards and Job Relevance:
   - The project implements basic functionalities such as searching for stores, retrieving store indices by category,
       and finding stores on a specific level. 
   - However, the project lacks certain features that are commonly seen in real-world applications, 
      such as error handling, input validation, and scalability considerations. 
  - It does demonstrate an understanding of basic data structures (arrays, lists) and algorithms (linear search).

# 2. Complexity and Ability to Solve Significant Problems:

     - The project solves a simple problem related to managing stores' information and performing basic operations on them.
     - However, the complexity is relatively low as it mainly involves linear search 
         operations on small datasets. There is no advanced algorithmic or data structure implementation.
     - To increase complexity and demonstrate the ability to solve significant problems, 
         one could consider implementing more advanced algorithms (e.g., binary search, sorting) or 
         data structures (e.g., hash maps, trees) to improve efficiency and scalability.

# 3. Areas for Improvement:

    - To enhance error handling and input validation to make the application more robust.
    - To implement more advanced algorithms and data structures to improve efficiency and 
       scalability, thus demonstrating a deeper understanding of problem-solving techniques.
    - To consider adding features that are more commonly encountered in real-world applications, 
      such as user authentication, data persistence, and a graphical user interface.

-** Overall, while the provided project demonstrates a basic understanding of data structures and algorithms, 
  there is room for improvement to better align with industry standards and showcase the ability to solve more significant problems.
```
## B Implementation of Data Structures
```csharp
- To evaluate the custom implementation of data structures or algorithms in the provided code
## a) Custom Implementation of Data Structures:

    i. The project utilizes basic data structures such as arrays and lists to manage store information.
    ii. While the implementation is straightforward and functional, it lacks custom implementations of 
      more advanced data structures like linked lists or hash tables.
    iii. To demonstrate a deeper understanding of data structures, consider implementing a custom linked list 
     or hash table to improve efficiency and showcase proficiency in building data structures from scratch.

## b) Algorithmic Complexity:

    i. The project primarily uses linear search algorithms to perform operations such as finding stores by name or category.
    ii. While linear search is appropriate for small datasets, it may become inefficient as the dataset grows.
    iii. Consider implementing more efficient search algorithms such as binary search or hash-based searching to improve performance, especially for larger datasets. 

## c) Understanding of Concepts:
    i. The code demonstrates a basic understanding of data structures and algorithms, as evidenced by the usage of arrays, lists, and linear search.
    ii. However, there is room for improvement in terms of exploring more advanced data structures and algorithms to solve problems more efficiently.

## d) Custom Implementation Opportunities:
    i. Explore opportunities to implement custom data structures and algorithms tailored to the specific requirements of the project.
     For example, designing a custom data structure to efficiently handle store lookup operations based on both name and 
     category could enhance performance and showcase creativity in problem-solving.

## e) Code Readability and Maintainability:
    i. Ensure that the code is well-structured, readable, and properly documented to facilitate understanding and future maintenance.
    ii. Consider adding comments and descriptive variable names to clarify the purpose and functionality of each component.

 -** Overall, while the provided code demonstrates a functional implementation of basic data structures and algorithms, 
     there are opportunities to enhance it by incorporating more advanced data structures, optimizing algorithmic complexity, 
     and improving code readability and maintainability. By addressing these aspects, 
     the project can better showcase an understanding of data structures and algorithms and the ability to build them from scratch.
```
## C. Project Innovation and Problem Solving
```csharp

- To reward creative solutions to problems, utilize technology in novel ways, 
   and address real-world issues in the provided code, we can consider the following enhancements:

## 1. Optimize Search Algorithms:

    i. Instead of linear search, implement more efficient search algorithms 
    like binary search or hash-based searching for faster store lookup operations, 
    especially with larger datasets.
## 2. Introduce Data Structures:

    i. Implement custom data structures such as hash tables or binary search trees to efficiently organize 
    and search store data by name, category, or location.

## 3. Enhance User Interaction:
    i. Develop a user-friendly interface that allows users to interactively search for stores, 
    browse by category, or view store locations on a map.

## 4. Real-world Integration:
    i. Integrate external APIs or services to enrich store data, such as retrieving 
     real-time information about store hours, ratings, or reviews from online platforms.

## 5. Data Analysis and Visualization:
     i . Analyze store data trends over time and visualize insights using charts or 
     graphs to help stakeholders make informed decisions, such as identifying popular store categories or busiest store locations.

## 6. Localization and Accessibility:
    i. Support multiple languages and ensure accessibility features to accommodate diverse user needs, making the application more inclusive
    and usable for a wider audience.

## 7. Error Handling and Resilience:
    i. Implement robust error handling mechanisms to gracefully handle unexpected scenarios, 
    such as network failures or invalid user inputs, ensuring the application remains resilient under adverse conditions.

## 8. Continuous Improvement:
     i. Establish a feedback loop to gather user feedback and iterate on the application based on insights and suggestions, 
     ontinuously improving its usability, performance, and feature set.
````
 ### D. Project Innovation and Problem Solving
 --To reward creative solutions, novel technology use, and address real-world issues, let's enhance the provided project in the following ways:
 ```csharp
# a) Dynamic Data Loading and Persistence: 
   Instead of statically defining store information within the code, integrate the project with a database or utilize an API to dynamically load 
   and persist store data. This approach makes the project more adaptable to changes in store information and allows for scalability.

# b) Implement Advanced Search Algorithms: 
  // Replace linear search with more efficient search algorithms such as binary search or hash-based searching. 
  //  This optimization will improve the performance of store lookups, especially as the dataset grows.

# c) Geolocation Integration: 
  //  Integrate geolocation services to enable users to find stores based on their current location. 
  // This feature enhances the project's real-world applicability and user experience by providing personalized store suggestions.

# d) Interactive User Interface (UI): 
 // Develop an interactive UI that offers features like filtering by category, sorting, and displaying store locations on a map. 
 // This enhances usability and engagement, making it easier for users to find relevant stores.

# e)Integration with E-commerce Platforms: 
 // Explore integration with e-commerce platforms to enable users to view product listings, make purchases, or place orders directly from the application. This integration bridges the gap between online and physical retail experiences, adding significant value.

# f) Predictive Analytics: 
 // Implement predictive analytics to suggest stores or products based on user preferences, past behavior, or popular trends. 
 // This feature enhances personalization and user engagement, driving sales and improving the overall user experience.

# g) Accessibility Features: 
 // Ensure the project is accessible to users with disabilities by incorporating features such as screen reader compatibility, keyboard navigation, 
 // and high contrast modes. Accessibility is crucial for inclusivity and compliance with accessibility standards.

# h) Localization and Multi-language Support: 
 // Implement localization and multi-language support to make the project accessible to users worldwide. 
 // This enhances the project's global reach and usability for diverse audiences.

  --** By incorporating these enhancements, the project will not only demonstrate creativity and 
     innovation but also address real-world issues faced by both consumers and businesses in the retail industry. 
     It will showcase the project's ability to leverage technology in novel ways to deliver value-added solutions.
```
 ## E. Project Innovation and Problem Solving
````csharp
 --**To reward creative solutions to problems, utilize technology in novel ways, 
   and address real-world issues in the provided code, we can consider the following enhancements:

 # 1. Optimize Search Algorithms:
//--Instead of linear search, implement more efficient search algorithms like binary search 
 or hash-based searching for faster store lookup operations, especially with larger datasets.

 # 2. Introduce Data Structures:
//--Implement custom data structures such as hash tables or binary search trees to efficiently organize 
 and search store data by name, category, or location.

# 3. Enhance User Interaction:
//--Develop a user-friendly interface that allows users to interactively search for stores, browse by category, 
 or view store locations on a map.

# 4. Real-world Integration:
//--Integrate external APIs or services to enrich store data, such as retrieving real-time information about store hours, ratings, 
 or reviews from online platforms.

# 5. Data Analysis and Visualization:
//--Analyze store data trends over time and visualize insights using charts or graphs to help stakeholders make informed decisions, 
 such as identifying popular store categories or busiest store locations.

# 6. Localization and Accessibility:
//--Support multiple languages and ensure accessibility features to accommodate diverse user needs, making the application more inclusive 
 and usable for a wider audience.

# 7. Error Handling and Resilience:
//--Implement robust error handling mechanisms to gracefully handle unexpected scenarios, 
  such as network failures or invalid user inputs, ensuring the application remains resilient under adverse conditions.

# 8. Continuous Improvement:
//--Establish a feedback loop to gather user feedback and iterate on the application based on insights 
 and suggestions, continuously improving its usability, performance, and feature set.

````
--** By incorporating these enhancements, the project can evolve from a basic store directory application to a sophisticated 
and innovative solution that effectively addresses real-world needs while demonstrating creativity, technological prowess, 
and practical utility.
```csharp
 ## F. Continuous Improvement and Learning

 --To evaluate evidence of ongoing project refinement, feature additions, adaptation to feedback, and learning of new skills through the project, we can consider the following aspects:

# 1. Version Control and Collaboration:
  i. Utilize version control systems like Git to track changes, collaborate with team members, and manage project iterations effectively. 
     Regularly commit code, create branches for new features, and incorporate feedback from peers or stakeholders through pull requests.

# 2. Agile Development Practices:
  ii. Embrace agile methodologies such as Scrum or Kanban to iteratively plan, execute, and review project tasks.
      Hold regular sprint meetings to prioritize backlog items, discuss progress, and adjust project direction based on emerging requirements or insights.

# 3. Continuous Integration and Deployment (CI/CD):
  iii. Implement CI/CD pipelines to automate build, test, and deployment processes, ensuring code quality, reliability,
      and scalability. Integrate tools like Jenkins or Azure DevOps to streamline development workflows and deliver updates to production efficiently.

# 4. Feedback Loops and User Testing:
  iv. Solicit feedback from end-users, stakeholders, and community members to identify areas for improvement, 
      validate assumptions, and gather insights for future enhancements. Conduct usability testing, surveys, or interviews 
      to capture user preferences, pain points, and feature requests.

# 5. Learning and Skill Development:
  v. Invest in continuous learning and skill development by exploring new technologies, frameworks, or programming languages relevant to the project domain. 
     Attend workshops, conferences, or online courses to expand knowledge, stay updated with industry trends, and apply best practices in project development.

# 6. Documentation and Knowledge Sharing:
  vi. Document project requirements, architecture, design decisions, and coding conventions to facilitate onboarding of new team members 
     and ensure continuity of development efforts. Establish a knowledge-sharing culture through internal wikis, 
     code reviews, and technical presentations to foster collaboration and collective learning.

# 7. Community Engagement and Open Source Contribution:
  vii. Engage with the developer community through forums, meetups, or open-source projects to exchange ideas, 
       seek advice, and contribute to shared repositories. Participate in hackathons, coding challenges, 
       or developer forums to showcase projects, receive feedback, and network with industry peers.

--By considering these criteria, you can evaluate how effectively the project evolves over time, 
  responds to feedback and user needs, and demonstrates ongoing learning and improvement.


## What is a Singly Linked List.

 - A singly linked list is a linear data structure where elements (nodes) are not stored in contiguous memory locations.
 - Each node contains two components:
 a. Data: The actual value or payload stored in the node.
 b. Next Pointer: A reference to the next node in the sequence.
 - The last node’s next pointer typically points to null, signifying the end of the list.

 ## How a Singly Linked List Works

 - We can traverse a singly linked list only in one direction (from the head to the tail).
 - Unlike arrays, singly linked lists do not provide direct access to elements by index.

 ## Basic Operations of Singly Linked List
 
 a). Insertion: Adding a new node to the list (at the beginning, end, or a specific position).
  b). Deletion: Removing a node from the list.
  c). Search: Finding a specific element.
  d). Length Calculation: Determining the number of nodes in the list.
  e). Reversal: Changing the order of nodes.

 ## Advanteges of Singly Linked List
  
  - Efficient for **Insertions** and **Deletions** (especially at the beginning).
  - Dynamic size (can grow or shrink as needed).
 ## Drawbacks:
  - **Random access** is not possible (no direct indexing).
  - **Extra memory overhead** due to the next pointers.
 
 
 ### Method Contains

The "contains" method will return weather or not a list contains a particular element or value. 

1. Start by declaring the method

```csharp
   amespace ConsMidTerm_Project
{
    public class LinkedList_Singly<T>
    {
        // Define a class for the linked list node 
        public class Node
        {
            public T Data { get; set; } // store name
            public Node Next { get; set; } // pointer to the next node

            // constructor that takes a data value
            public Node(T data)
            {
                Data = data;
                Next = null;
            }
        }
        private Node head; // pointer to the first node
        private int count; // number of nodes in the list

        // Public property to access the number of elements in the list
        public int Count => count;

        // Define a class for the linked list
        public LinkedList_Singly()
        {
            head = null;
            count = 0;
        }
        // method to add a node at the end of the list
        public void Add(T data)
        {
            Node newNode = new Node(data); // create a new node
            if (head == null) // if the list is empty
            {
                head = newNode; // set the head to the new node
            }
            else // if the list is not empty
            {
                Node current = head; // start from the head
                while (current.Next != null) // loop until the last node
                {
                    current = current.Next; // move to the next node
                }
                current.Next = newNode; // add the new node to the end
            }
            count++; // increment the count
        }
        // method to display the elements of the list
        public void Display()
        {
            Node current = head;
            while (current != null)
            {
                Console.WriteLine(current.Data);
                current = current.Next;
            }
        }
        // Core Method: Remove elements by their values
        public void Remove(T data)
        {
            if (head == null)
            {
                return; // Empty list, nothing to remove
            }

            if (head.Data.Equals(data))
            {
                head = head.Next;
                count--;
                return;
            }

            Node current = head;
            while (current.Next != null && !current.Next.Data.Equals(data))
            {
                current = current.Next;
            }

            if (current.Next != null)
            {
                current.Next = current.Next.Next;
                count--;
            }
        }
        // Indexer override to access elements by index
        public T this[int index]
        {
            get
            {
                if (index < 0 || index >= count)
                {
                    throw new IndexOutOfRangeException();
                }

                Node current = head;
                for (int i = 0; i < index; i++)
                {
                    current = current.Next;
                }

                return current.Data;
            }
        }

        // Additional Methods for inserting elements

        public void InsertAtIndex(int index, T data)
        {
            if (index < 0 || index > count)
            {
                throw new IndexOutOfRangeException();
            }

            Node newNode = new Node(data);
            Node current = head;

            for (int i = 0; i < index - 1; i++)
            {
                current = current.Next;
            }

            newNode.Next = current.Next;
            current.Next = newNode;

            count++;
        }

        // Method to clear the linked list
        public void Clear()
        {
            head = null;
            count = 0;
        }
    }
}
 
    
`````
`````csharp

namespace ConsMidTerm_Project
{
    public class Program
    {
        // Declare the global linked list
        static LinkedList<string> StoreDirectory;

        static void Main(string[] args)
        {
            Preload();

            Console.WriteLine("Contains");
            Console.WriteLine(StoreDirectory.Contains("Aqua Adventures").ToString()); // True
            Console.WriteLine(StoreDirectory.Contains("Zara").ToString()); // False
            Console.WriteLine("Print");
            PrintStoreNames(); // print the store names
            // Create a new node with the store name
            var newNode = new LinkedListNode<string>("New Store Name");
            StoreDirectory.AddLast(newNode);// print the store names
        }
        // Method to preload the store names into the linked list
        static void Preload()
        {
            StoreDirectory = new LinkedList<string>(); // create a new linked list
            StoreDirectory.AddLast("Aqua Adventures"); // add store names
            StoreDirectory.AddLast("Barnes & Noble");
            StoreDirectory.AddLast("Dairy Queen");
            StoreDirectory.AddLast("Express");
            StoreDirectory.AddLast("Foot Locker");
            StoreDirectory.AddLast("Gap");
            StoreDirectory.AddLast("H&M");
            StoreDirectory.AddLast("IHOP");
            StoreDirectory.AddLast("JCPenney");



            // Create a linked list of strings
            LinkedList_Singly<string> list = new LinkedList_Singly<string>();
            // Add some elements to the list
            list.Add("Hello");
            list.Add("World");
            list.Add("!");

            // Display the list
            list.Display();

            // Remove the first element
            //list.Remove("Hello");

            // Display the list again
            list.Display();

            // Insert an element at index 1
            list.InsertAtIndex(1, "C#");

            // Display the list again
            list.Display();

            // Clear the list
           //list.Clear();

            // Display the list again
            //list.Display();

        }
        // Method to print store names
        static void PrintStoreNames()
        {
            foreach (var storeName in StoreDirectory)
            {
                Console.WriteLine(storeName);
            }

        }
    }
}
````

```csharp
public static bool ContainsStore(string[] storeList, string searchKey) {

    // Using a foreach to loop through our array starting from the first element
    foreach (string store in storeList)
    {

    }
    
}
```

3. Now we are adding our conditional statement inside of our loop. Each time we loop we are comparing the current element to what we are searching for.


```csharp
public static bool ContainsStore(string[] storeList, string searchKey)
{
    foreach (string store in storeList)
    {
        // Adding a condition to compare the current element to what we are searching for
        if (store == searchKey)
        {
 
        }
    }
}
```

4. Now we write our code that will respond if when our search matches the current element. Since we are just looking to see if a element matches, we return true inside of our condition.

```csharp
public static bool ContainsStore(string[] storeList, string searchKey)
{
    foreach (string store in storeList)
    {
        if (store == searchKey)
        {
            // The first time we find a matching value we return true. This immedietly stops the loop and exits the method.
            return true;
        }
    }
}
```

5. What happens if we don't find a matching element? Then we need to return false to indicate it doesn't exist. We do this by declaring `return false` outside of our loop. This return false will only run once we have loop through our entire list and and element hasn't been found.

```csharp
public static bool ContainsStore(string[] storeList, string searchKey)
{
    foreach (string store in storeList)
    {
        if (store == searchKey)
        {
            return true;
        }
    }
    // Return false runs if not matching element is found.
    return false;
}
```


6. Now lets test our method.

On our first call, it will return `true` becuase the store ***Aqua Adventures*** exists in our store directory.

But the second call returns false, because ***Box Lunch*** is not in the directory.

```csharp
public static void Main(string[] args) {
    Console.WriteLine("Contains");
    Console.WriteLine(ContainsStore(storeDirectory, "Aqua Adventures").ToString()); // True
    Console.WriteLine(ContainsStore(storeDirectory, "Box Lunch").ToString()); // False
}
```


---

### Method: StoreByCategory

While contains will return if an item exists we can get a similar result and also more information by returning the index.

Here we working with our parallel arrays, our stores and the categories. We will create a method that will find the first instance of a Category name and then return the resulting index. If the item isn't found, we return -1.

1. Start by declaring our method, which is bascially the same signature our our contains, but it returns an int for the index. We will also add a for loop, as we need to grab the index.

```csharp
// Declare our method that will take a collection, something to search for, and return an index.
public static int StoreByCategory(string[] categoryList, string searchKey)
{
// Use a for loop to iterate through our list. We can't use a foreach, because we wouldn't have access to the index that we need to return
    for (int i = 0; i < categoryList.Length; i++)
    {

    }
 
}
```

2. Now will add our condition that will run if we find a match. 
- We will also add our return statement, which will be `return i;`, inside our condition. This returns the location of the value we found. We can then pass in that index to our store array to get the related information.
![Result Index](Images/ResultIndex.PNG)


```csharp
public static int StoreByCategory(string[] categoryList, string searchKey)
{
    for (int i = 0; i < storeList.Length; i++)
    {
        if (categoryList[i] == searchKey)
        {
            return i;
        }
    }
    return -1; // Return -1 if not found
}
```


- We also write `return -1` which runs if we do not find a matching element. We can then write a responding if statement that checks if our value is -1.

```csharp
    int containsCategory = StoreByCategory(categoryList, "Food"); // -1

    if(containsCategory == -1) // Category doesn't exist
```

3. Test our results

```csharp
public static void Main(string[] args) {
Console.WriteLine("Store By Index");
Console.WriteLine(StoreByCategory(storeCategories, "Entertainment").ToString()); // 1
Console.WriteLine(StoreByCategory(storeCategories, "Food").ToString()); // -1
}
```

---

